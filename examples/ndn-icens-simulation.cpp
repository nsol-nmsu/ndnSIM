#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/ndnSIM-module.h"

#include <iostream>
#include <fstream>

namespace ns3 {

/**
 * This scenario simulates network graph generated by TopoMux (NMSU NSOL):
 *
 *     NS_LOG=ndn.Subscriber::ndn.SpontaneousProducer ./waf --run ndn-icens-simulation
 */


bool ValidatePrefix(int, std::string, std::string);
bool PrefixAdded(std::string, std::string);

// Vectors to store the various node types
vector<int> com_nodes, agg_nodes, phy_nodes;
// Vector to store distinct prefixes being served by the node types
vector<string> com_prefixes;

int
main(int argc, char* argv[])
{

  //--- Count the number of nodes to create
  ifstream nfile ("src/ndnSIM/examples/icens-nodes.txt", std::ios::in);
  std::string nodeid, nodename, nodetype;
  int nodecount = 0;

  if (nfile.is_open ()) {
  	while (nfile >> nodeid >> nodename >> nodetype) {
	//while(std::getline(nfile,line)){
		nodecount += 1;

		if (nodename.substr(0,4) == "com_") {
			com_nodes.push_back(std::stoi(nodeid));
		}
		else if (nodename.substr(0,4) == "agg_") {
			agg_nodes.push_back(std::stoi(nodeid));
		}
		else if (nodename.substr(0,4) == "phy_") {
			phy_nodes.push_back(std::stoi(nodeid));
		}
		else {
			cout << "Error::Node not classified" << endl;
		}
  	}
  }
  else {
	std::cout << "Error::Cannot open nodes file!!!" << std::endl;
  }
  nfile.close();

  // setting default parameters for PointToPoint links and channels
  Config::SetDefault("ns3::PointToPointNetDevice::DataRate", StringValue("1Mbps"));
  Config::SetDefault("ns3::PointToPointChannel::Delay", StringValue("10ms"));
  Config::SetDefault("ns3::DropTailQueue::MaxPackets", StringValue("20"));

  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize
  CommandLine cmd;
  cmd.Parse(argc, argv);

  // Creating the number of nodes counted in the nodes file
  NodeContainer nodes;
  nodes.Create(nodecount);

  // Connecting nodes using two links
  PointToPointHelper p2p;

  //--- Get the edges of the graph from file and connect them
  ifstream efile ("src/ndnSIM/examples/icens-edges.txt", std::ios::in);
  std::string srcnode, dstnode, bw, delay, edgetype;

  if (efile.is_open ()) {
        while (efile >> srcnode >> dstnode >> bw >> delay >> edgetype) {
		p2p.Install(nodes.Get(std::stoi(srcnode)), nodes.Get(std::stoi(dstnode)));
        }
  }
  else {
        std::cout << "Error::Cannot open edges file!!!" << std::endl;
  }
  efile.close();

  // Install NDN stack on all nodes
  ndn::StackHelper ndnHelper;
  ndnHelper.InstallAll();


  //--- Configure manual/static routes on all nodes
  //--- Install spontaneous producer application for each prefix that a node serves
  ifstream rfile("src/ndnSIM/examples/icens-routing-tables.txt", std::ios::in);
  Ptr<Node> currentnode, nexthopnode;
  std::string strfrom, prefixtoroute, strnexthop, strmetric;
  int metric;


  if (rfile.is_open ()) {
	// Spontaneuos producer helper
	ndn::AppHelper spHelper("ns3::ndn::SpontaneousProducer");

        while (rfile >> strfrom >> prefixtoroute >> strnexthop >> strmetric) {

		if (strnexthop == "local") {
			 // Install spontaneous producer on the node for the prefix being served
			 spHelper.SetPrefix(prefixtoroute);
  			 spHelper.SetAttribute("Frequency", StringValue("1")); //how many seconds to wait before sending data for subscription interest
  			 spHelper.SetAttribute("PayloadSize", StringValue("1024"));
  			 spHelper.Install(nodes.Get(std::stoi(strfrom)));

			// Store the prefix, will be used by physical nodes for subscription requests
			if (ns3::ValidatePrefix(std::stoi(strfrom), prefixtoroute, "com_") == true) {
				com_prefixes.push_back(prefixtoroute);
			}

			 //std::cout << "installing " << prefixtoroute << " on node " << strfrom << std::endl;
		}
		else {
			// Configure statuc route on node
			currentnode = nodes.Get(std::stoi(strfrom)); // node to add route on
			prefixtoroute = prefixtoroute; // prefix to add route for
			nexthopnode = nodes.Get(std::stoi(strnexthop));     // next hop node
			metric = std::stoi(strmetric);     // metric or cost
			ndn::FibHelper::AddRoute(currentnode, prefixtoroute, nexthopnode, metric);
			//std::cout << "configuring static route for prefix " << prefixtoroute << " on node " << strfrom << endl;
		}
        }
  }
  else {
        std::cout << "Error::Cannot open routing table file!!!" << std::endl;
  }
  rfile.close();

  // Choosing forwarding strategy
  ndn::StrategyChoiceHelper::InstallAll("/prefix", "/localhost/nfd/strategy/multicast");

  // Installing applications

  // Subscriber
  ndn::AppHelper consumerHelper("ns3::ndn::Subscriber");
  // Subscriber send out subscription interest for a prefix...

  // Each physical layer node, subscribes to prefixe being served by all computes nodes
  for (int i=0; i<(int)com_prefixes.size(); i++) {
  	for (int j=0; j<(int)phy_nodes.size(); j++) {
		consumerHelper.SetPrefix(com_prefixes[i]);
		consumerHelper.SetAttribute("TxTimer", StringValue("15")); //resend subscription interest every 5 seconds
  		consumerHelper.Install(nodes.Get(phy_nodes[j]));
  	}
  }

  Simulator::Stop(Seconds(5.0));

  Simulator::Run();
  Simulator::Destroy();

  return 0;
}


// Get the prefixes served the nodes at the various layers
bool ValidatePrefix(int nodeid, std::string prefix, std::string nodetype) {
        // verify if node id belongs to the node type passed to function
        if (nodetype == "com_") {
                for (int i=0; i<(int)com_nodes.size(); i++) {
                        if (com_nodes[i] == nodeid) {
				if (PrefixAdded(prefix, nodetype) == false) {
                                	return true;
				}
                        }
                }
        }
	else if (nodetype == "agg_") {

	}
        else if (nodetype == "phy_") {

        }

        return false;
}

bool PrefixAdded(std::string prefix, std::string nodetype) {

	if (nodetype == "com_") {
		// check if prefix is already detected as being served by compute node
		for (int i=0; i<(int)com_prefixes.size(); i++) {
			if (prefix == com_prefixes[i]) {
				return true;
			}
		}
	}
	else if (nodetype == "agg_") {

	}
	else if (nodetype == "phy_") {

        }

	return false;
}

} // namespace ns3

int
main(int argc, char* argv[])
{
  return ns3::main(argc, argv);
}
