<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ndnSIM for iCenS: /home/network/NSOL/ndnSIM-dev/ns-3/src/ndnSIM/NFD/websocketpp/tutorials/utility_client/utility_client.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ndnSIM for iCenS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,'Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/network/NSOL/ndnSIM-dev/ns-3/src/ndnSIM/NFD/websocketpp/tutorials/utility_client/utility_client.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Utility Client Example Application</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;==================================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Chapter 1: Initial Setup &amp; Basics</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;---------------------------------</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Setting up the basic types, opening and closing connections, sending and receiving messages.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;### Step 1</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;A basic program loop that prompts the user for a command and then processes it. In this tutorial we will modify this program to perform tasks and retrieve data from a remote server over a WebSocket connection.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;#### Build</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;`clang++ step1.cpp`</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;#### Code so far</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;*note* A code snapshot for each step is present next to this tutorial file in the git repository.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;```cpp</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;#include &lt;iostream&gt;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;#include &lt;string&gt;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;int main() {</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    bool done = false;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    std::string input;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    while (!done) {</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        std::cout &lt;&lt; &quot;Enter Command: &quot;;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        std::getline(std::cin, input);</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        if (input == &quot;quit&quot;) {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;            done = true;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        } else if (input == &quot;help&quot;) {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            std::cout</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                &lt;&lt; &quot;\nCommand List:\n&quot;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                &lt;&lt; &quot;help: Display this help text\n&quot;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                &lt;&lt; &quot;quit: Exit the program\n&quot;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                &lt;&lt; std::endl;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        } else {</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            std::cout &lt;&lt; &quot;Unrecognized Command&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        }</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    return 0;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;```</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;### Step 2</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;_Add WebSocket++ includes and set up an endpoint type._</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;WebSocket++ includes two major object types. The endpoint and the connection. The</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;endpoint creates and launches new connections and maintains default settings for</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;those connections. Endpoints also manage any shared network resources.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;The connection stores information specific to each WebSocket session.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;&gt; **Note:** Once a connection is launched, there is no link between the endpoint and the connection. All default settings are copied into the new connection by the endpoint. Changing default settings on an endpoint will only affect future connections.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;Connections do not maintain a link back to their associated endpoint. Endpoints do not maintain a list of outstanding connections. If your application needs to iterate over all connections it will need to maintain a list of them itself.</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;WebSocket++ endpoints are built by combining an endpoint role with an endpoint config. There are two different types of endpoint roles, one each for the client and server roles in a WebSocket session. This is a client tutorial so we will use the client role `websocketpp::client` which is provided by the `&lt;websocketpp/client.hpp&gt;` header.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;&gt; ###### Terminology: Endpoint Config</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;&gt; WebSocket++ endpoints have a group of settings that may be configured at compile time via the `config` template parameter. A config is a struct that contains types and static constants that are used to produce an endpoint with specific properties. Depending on which config is being used the endpoint will have different methods available and may have additional third party dependencies.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;The endpoint role takes a template parameter called `config` that is used to configure the behavior of endpoint at compile time. For this example we are going to use a default config provided by the library called `asio_client`, provided by `&lt;websocketpp/config/asio_no_tls_client.hpp&gt;`. This is a client config that uses boost::asio to provide network transport and does not support TLS based security. Later on we will discuss how to introduce TLS based security into a WebSocket++ application, more about the other stock configs, and how to build your own custom configs.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;Combine a config with an endpoint role to produce a fully configured endpoint. This type will be used frequently so I would recommend a typedef here.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;`typedef websocketpp::client&lt;websocketpp::config::asio_client&gt; client`</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;#### Build</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;Adding WebSocket++ has added a few dependencies to our program that must be addressed in the build system. Firstly, the WebSocket++ and Boost library headers must be in the include search path of your build system. How exactly this is done depends on where you have the WebSocket++ headers installed and what build system you are using.</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;In addition to the new headers, boost::asio depends on the `boost_system` shared library. This will need to be added (either as a static or dynamic) to the linker. Refer to your build environment documentation for instructions on linking to shared libraries.</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;`clang++ step2.cpp -lboost_system`</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;#### Code so far</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;```cpp</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;#include &lt;websocketpp/config/asio_no_tls_client.hpp&gt;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;#include &lt;websocketpp/client.hpp&gt;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;#include &lt;iostream&gt;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;#include &lt;string&gt;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;typedef websocketpp::client&lt;websocketpp::config::asio_client&gt; client;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;int main() {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    bool done = false;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    std::string input;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    while (!done) {</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        std::cout &lt;&lt; &quot;Enter Command: &quot;;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        std::getline(std::cin, input);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        if (input == &quot;quit&quot;) {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            done = true;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        } else if (input == &quot;help&quot;) {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            std::cout</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                &lt;&lt; &quot;\nCommand List:\n&quot;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                &lt;&lt; &quot;help: Display this help text\n&quot;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                &lt;&lt; &quot;quit: Exit the program\n&quot;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                &lt;&lt; std::endl;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        } else {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            std::cout &lt;&lt; &quot;Unrecognized Command&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    }</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    return 0;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;```</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;### Step 3</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;_Create endpoint wrapper object that handles initialization and setting up the background thread._</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;In order to process user input while network processing occurs in the background we are going to use a separate thread for the WebSocket++ processing loop. This leaves the main thread free to process foreground user input. In order to enable simple RAII style resource management for our thread and endpoint we will use a wrapper object that configures them both in its constructor.</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;&gt; ###### Terminology: websocketpp::lib namespace</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;&gt; WebSocket++ is designed to be used with a C++11 standard library. As this is not universally available in popular build systems the Boost libraries may be used as polyfills for the C++11 standard library in C++98 build environments. The `websocketpp::lib` namespace is used by the library and its associated examples to abstract away the distinctions between the two. `websocketpp::lib::shared_ptr` will evaluate to `std::shared_ptr` in a C++11 environment and `boost::shared_ptr` otherwise.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;&gt;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;&gt; This tutorial uses the `websocketpp::lib` wrappers because it doesn&#39;t know what the build environment of the reader is. For your applications, unless you are interested in similar portability, are free to use the boost or std versions of these types directly.</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;&gt;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;&gt;[TODO: link to more information about websocketpp::lib namespace and C++11 setup]</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;Within the `websocket_endpoint` constructor several things happen:</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;First, we set the endpoint logging behavior to silent by clearing all of the access and error logging channels. [TODO: link to more information about logging]</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;```cpp</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;m_endpoint.clear_access_channels(websocketpp::log::alevel::all);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;m_endpoint.clear_error_channels(websocketpp::log::elevel::all);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;```</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;Next, we initialize the transport system underlying the endpoint and set it to perpetual mode. In perpetual mode the endpoint&#39;s processing loop will not exit automatically when it has no connections. This is important because we want this endpoint to remain active while our application is running and process requests for new WebSocket connections on demand as we need them. Both of these methods are specific to the asio transport. They will not be  necessary or present in endpoints that use a non-asio config.</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;```cpp</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;m_endpoint.init_asio();</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;m_endpoint.start_perpetual();</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;```</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Finally, we launch a thread to run the `run` method of our client endpoint. While the endpoint is running it will process connection tasks (read and deliver incoming messages, frame and send outgoing messages, etc). Because it is running in perpetual mode, when there are no connections active it will wait for a new connection.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;```cpp</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;m_thread.reset(new websocketpp::lib::thread(&amp;client::run, &amp;m_endpoint));</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;```</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;#### Build</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;Now that our client endpoint template is actually instantiated a few more linker dependencies will show up. In particular, WebSocket clients require a cryptographically secure random number generator. WebSocket++ is able to use either `boost_random` or the C++11 standard library &lt;random&gt; for this purpose. Because this example also uses threads, if we do not have C++11 std::thread available we will need to include `boost_thread`.</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;##### Clang (C++98 &amp; boost)</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;`clang++ step3.cpp -lboost_system -lboost_random -lboost_thread`</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;##### Clang (C++11)</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;`clang++ -std=c++0x -stdlib=libc++ step3.cpp -lboost_system -D_WEBSOCKETPP_CPP11_STL_`</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;##### G++ (C++98 &amp; Boost)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;`g++ step3.cpp -lboost_system -lboost_random -lboost_thread`</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;##### G++ v4.6+ (C++11)</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;`g++ -std=c++0x step3.cpp -lboost_system -D_WEBSOCKETPP_CPP11_STL_`</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;#### Code so far</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;```cpp</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;#include &lt;websocketpp/config/asio_no_tls_client.hpp&gt;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;#include &lt;websocketpp/client.hpp&gt;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;#include &lt;websocketpp/common/thread.hpp&gt;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;#include &lt;websocketpp/common/memory.hpp&gt;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;#include &lt;iostream&gt;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;#include &lt;string&gt;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;typedef websocketpp::client&lt;websocketpp::config::asio_client&gt; client;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;class websocket_endpoint {</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;public:</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    websocket_endpoint () {</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        m_endpoint.init_asio();</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        m_endpoint.start_perpetual();</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        m_thread.reset(new websocketpp::lib::thread(&amp;client::run, &amp;m_endpoint));</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    }</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;private:</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    client m_endpoint;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    websocketpp::lib::shared_ptr&lt;websocketpp::lib::thread&gt; m_thread;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;};</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;int main() {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    bool done = false;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    std::string input;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    websocket_endpoint endpoint;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    while (!done) {</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        std::cout &lt;&lt; &quot;Enter Command: &quot;;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        std::getline(std::cin, input);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        if (input == &quot;quit&quot;) {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            done = true;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        } else if (input == &quot;help&quot;) {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            std::cout</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                &lt;&lt; &quot;\nCommand List:\n&quot;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                &lt;&lt; &quot;help: Display this help text\n&quot;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                &lt;&lt; &quot;quit: Exit the program\n&quot;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                &lt;&lt; std::endl;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        } else {</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            std::cout &lt;&lt; &quot;Unrecognized Command&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        }</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    }</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    return 0;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;}</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;```</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;### Step 4</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;_Opening WebSocket connections_</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;This step adds two new commands to utility_client. The ability to open a new connection and the ability to view information about a previously opened connection. Every connection that gets opened will be assigned an integer connection id that the user of the program can use to interact with that connection.</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;#### New Connection Metadata Object</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;In order to track information about each connection a `connection_metadata` object is defined. This object stores the numeric connection id and a number of fields that will be filled in as the connection is processed. Initially this includes the state of the connection (opening, open, failed, closed, etc), the original URI connected to, an identifying value from the server, and a description of the reason for connection failure/closure. Future steps will add more information to this metadata object.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;#### Update `websocket_endpoint`</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;The `websocket_endpoint` object has gained some new data members and methods. It now tracks a mapping between connection IDs and their associated metadata as well as the next sequential ID number to hand out. The `connect()` method initiates a new connection. The `get_metadata` method retrieves metadata given an ID.</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;#### The connect method</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;A new WebSocket connection is initiated via a three step process. First, a connection request is created by `endpoint::get_connection(uri)`. Next, the connection request is configured. Lastly, the connection request is submitted back to the endpoint via `endpoint::connect()` which adds it to the queue of new connections to make.</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;&gt; ###### Terminology `connection_ptr`</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;&gt; WebSocket++ keeps track of connection related resources using a reference counted shared pointer. The type of this pointer is `endpoint::connection_ptr`. A `connection_ptr` allows direct access to information about the connection and allows changing connection settings. Because of this direct access and their internal resource management role within the library it is not safe to for end applications to use `connection_ptr` except in the specific circumstances detailed below.</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;&gt;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;&gt; **When is it safe to use `connection_ptr`?**</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;&gt; - After `endpoint::get_connection(...)` and before `endpoint::connect()`: `get_connection` returns a `connection_ptr`. It is safe to use this pointer to configure your new connection. Once you submit the connection to `connect` you may no longer use the `connection_ptr` and should discard it immediately for optimal memory management.</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;&gt; - During a handler: WebSocket++ allows you to register hooks / callbacks / event handlers for specific events that happen during a connection&#39;s lifetime. During the invocation of one of these handlers the library guarantees that it is safe to use a `connection_ptr` for the connection associated with the currently running handler.</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;&gt; ###### Terminology `connection_hdl`</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;&gt; Because of the limited thread safety of the `connection_ptr` the library also provides a more flexible connection identifier, the `connection_hdl`. The `connection_hdl` has type `websocketpp::connection_hdl` and it is defined in `&lt;websocketpp/common/connection_hdl.hpp&gt;`. Note that unlike `connection_ptr` this is not dependent on the type or config of the endpoint. Code that simply stores or transmits `connection_hdl` but does not use them can include only the header above and can treat its hdls like values.</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;&gt;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;&gt; Connection handles are not used directly. They are used by endpoint methods to identify the target of the desired action. For example, the endpoint method that sends a new message will take as a parameter the hdl of the connection to send the message to.</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;&gt;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;&gt; **When is it safe to use `connection_hdl`?**</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;&gt; `connection_hdl`s may be used at any time from any thread. They may be copied and stored in containers. Deleting a hdl will not affect the connection in any way. Handles may be upgraded to a `connection_ptr` during a handler call by using `endpoint::get_con_from_hdl()`. The resulting `connection_ptr` is safe to use for the duration of that handler invocation.</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;&gt;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;&gt; **`connection_hdl` FAQs**</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;&gt; - `connection_hdl`s are guaranteed to be unique within a program. Multiple endpoints in a single program will always create connections with unique handles.</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;&gt; - Using a `connection_hdl` with a different endpoint than the one that created its associated connection will result in undefined behavior.</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;&gt; - Using a `connection_hdl` whose associated connection has been closed or deleted is safe. The endpoint will return a specific error saying the operation couldn&#39;t be completed because the associated connection doesn&#39;t exist.</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;&gt; [TODO: more here? link to a connection_hdl FAQ elsewhere?]</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;`websocket_endpoint::connect()` begins by calling `endpoint::get_connection()` using a uri passed as a parameter. Additionally, an error output value is passed to capture any errors that might occur during. If an error does occur an error notice is printed along with a descriptive message and the -1 / &#39;invalid&#39; value is returned as the new ID.</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;&gt; ###### Terminology: `error handling: exceptions vs error_code`</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;&gt; WebSocket++ uses the error code system defined by the C++11 `&lt;system_error&gt;` library. It can optionally fall back to a similar system provided by the Boost libraries. All user facing endpoint methods that can fail take an `error_code` in an output parameter and store the error that occured there before returning. An empty/default constructed value is returned in the case of success.</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;&gt;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;&gt; **Exception throwing varients**</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;&gt; All user facing endpoint methods that take and use an `error_code` parameter have a version that throws an exception instead. These methods are identical in function and signature except for the lack of the final ec parameter. The type of the exception thrown is `websocketpp::exception`. This type derives from `std::exception` so it can be caught by catch blocks grabbing generic `std::exception`s. The `websocketpp::exception::code()` method may be used to extract the machine readable `error_code` value from an exception.</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;&gt;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;&gt; For clarity about error handling the utility_client example uses exclusively the exception free varients of these methods. Your application may choose to use either.</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;If connection creation succeeds, the next sequential connection ID is generated and a `connection_metadata` object is inserted into the connection list under that ID. Initially the metadata object stores the connection ID, the `connection_hdl`, and the URI the connection was opened to.</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;```cpp</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;int new_id = m_next_id++;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;metadata_ptr metadata(new connection_metadata(new_id, con-&gt;get_handle(), uri));</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;m_connection_list[new_id] = metadata;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;```</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;Next, the connection request is configured. For this step the only configuration we will do is setting up a few default handlers. Later on we will return and demonstrate some more detailed configuration that can happen here (setting user agents, origin, proxies, custom headers, subprotocols, etc).</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;&gt; ###### Terminology: Registering handlers</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;&gt; WebSocket++ provides a number of execution points where you can register to have a handler run. Which of these points are available to your endpoint will depend on its config. TLS handlers will not exist on non-TLS endpoints for example. A complete list of handlers can be found at  http://www.zaphoyd.com/websocketpp/manual/reference/handler-list.</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;&gt;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;&gt; Handlers can be registered at the endpoint level and at the connection level. Endpoint handlers are copied into new connections as they are created. Changing an endpoint handler will affect only future connections. Handlers registered at the connection level will be bound to that specific connection only.</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;&gt;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;&gt; The signature of handler binding methods is the same for endpoints and connections. The format is: `set_*_handler(...)`. Where * is the name of the handler. For example, `set_open_handler(...)` will set the handler to be called when a new connection is open. `set_fail_handler(...)` will set the handler to be called when a connection fails to connect.</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;&gt;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;&gt; All handlers take one argument, a callable type that can be converted to a `std::function` with the correct count and type of arguments. You can pass free functions, functors, and Lambdas with matching argument lists as handlers. In addition, you can use `std::bind` (or `boost::bind`) to register functions with non-matching argument lists. This is useful for passing additional parameters not present in the handler signature or member functions that need to carry a &#39;this&#39; pointer.</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;&gt;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;&gt; The function signature of each handler can be looked up in the list above in the manual. In general, all handlers include the `connection_hdl` identifying which connection this even is associated with as the first parameter. Some handlers (such as the message handler) include additional parameters. Most handlers have a void return value but some (`validate`, `ping`, `tls_init`) do not. The specific meanings of the return values are documented in the handler list linked above.</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;`utility_client` registers an open and a fail handler. We will use these to track whether each connection was successfully opened or failed. If it successfully opens, we will gather some information from the opening handshake and store it with our connection metadata.</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;In this example we are going to set connection specific handlers that are bound directly to the metadata object associated with our connection. This allows us to avoid performing a lookup in each handler to find the metadata object we plan to update which is a bit more efficient.</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;Lets look at the parameters being sent to bind in detail:</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;```cpp</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;con-&gt;set_open_handler(websocketpp::lib::bind(</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    &amp;connection_metadata::on_open,</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    metadata,</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    &amp;m_endpoint,</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    websocketpp::lib::placeholders::_1</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;));</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;```</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;`&amp;connection_metadata::on_open` is the address of the `on_open` member function of the `connection_metadata` class. `metadata_ptr` is a pointer to the `connection_metadata` object associated with this class. It will be used as the object on which the `on_open` member function will be called. `&amp;m_endpoint` is the address of the endpoint in use. This parameter will be passed as-is to the `on_open` method. Lastly, `websocketpp::lib::placeholders::_1` is a placeholder indicating that the bound function should take one additional argument to be filled in at a later time. WebSocket++ will fill in this placeholder with the `connection_hdl` when it invokes the handler.</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;Finally, we call `endpoint::connect()` on our configured connection request and return the new connection ID.</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;#### Handler Member Functions</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;The open handler we registered, `connection_metadata::on_open`, sets the status metadata field to &quot;Open&quot; and retrieves the value of the &quot;Server&quot; header from the remote endpoint&#39;s HTTP response and stores it in the metadata object. Servers often set an identifying string in this header.</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;The fail handler we registered, `connection_metadata::on_fail`, sets the status metadata field to &quot;Failed&quot;, the server field similarly to `on_open`, and retrieves the error code describing why the connection failed. The human readable message associated with that error code is saved to the metadata object.</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;#### New Commands</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;Two new commands have been set up. &quot;connect [uri]&quot; will pass the URI to the `websocket_endpoint` connect method and report an error or the connection ID of the new connection. &quot;show [connection id]&quot; will retrieve and print out the metadata associated with that connection. The help text has been updated accordingly.</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;```cpp</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;} else if (input.substr(0,7) == &quot;connect&quot;) {</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    int id = endpoint.connect(input.substr(8));</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    if (id != -1) {</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        std::cout &lt;&lt; &quot;&gt; Created connection with id &quot; &lt;&lt; id &lt;&lt; std::endl;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    }</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;} else if (input.substr(0,4) == &quot;show&quot;) {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    int id = atoi(input.substr(5).c_str());</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    connection_metadata::ptr metadata = endpoint.get_metadata(id);</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    if (metadata) {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        std::cout &lt;&lt; *metadata &lt;&lt; std::endl;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    } else {</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        std::cout &lt;&lt; &quot;&gt; Unknown connection id &quot; &lt;&lt; id &lt;&lt; std::endl;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    }</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;}</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;```</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;#### Build</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;There are no changes to the build instructions from step 3</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;#### Run</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;```</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;Enter Command: connect not a websocket uri</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;&gt; Connect initialization error: invalid uri</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;Enter Command: show 0</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;&gt; Unknown connection id 0</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;Enter Command: connect ws://echo.websocket.org</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;&gt; Created connection with id 0</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;Enter Command: show 0</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;&gt; URI: ws://echo.websocket.org</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;&gt; Status: Open</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;&gt; Remote Server: Kaazing Gateway</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;&gt; Error/close reason: N/A</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;Enter Command: connect ws://wikipedia.org</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;&gt; Created connection with id 1</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;Enter Command: show 1</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;&gt; URI: ws://wikipedia.org</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;&gt; Status: Failed</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;&gt; Remote Server: Apache</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;&gt; Error/close reason: Invalid HTTP status.</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;```</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;#### Code so far</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;```cpp</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;#include &lt;websocketpp/config/asio_no_tls_client.hpp&gt;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;#include &lt;websocketpp/client.hpp&gt;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;#include &lt;websocketpp/common/thread.hpp&gt;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;#include &lt;websocketpp/common/memory.hpp&gt;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;#include &lt;cstdlib&gt;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;#include &lt;iostream&gt;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;#include &lt;map&gt;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;#include &lt;string&gt;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;#include &lt;sstream&gt;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;typedef websocketpp::client&lt;websocketpp::config::asio_client&gt; client;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;class connection_metadata {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;public:</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    typedef websocketpp::lib::shared_ptr&lt;connection_metadata&gt; ptr;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    connection_metadata(int id, websocketpp::connection_hdl hdl, std::string uri)</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;      : m_id(id)</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;      , m_hdl(hdl)</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;      , m_status(&quot;Connecting&quot;)</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;      , m_uri(uri)</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      , m_server(&quot;N/A&quot;)</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    {}</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    void on_open(client * c, websocketpp::connection_hdl hdl) {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        m_status = &quot;Open&quot;;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        client::connection_ptr con = c-&gt;get_con_from_hdl(hdl);</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        m_server = con-&gt;get_response_header(&quot;Server&quot;);</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    }</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    void on_fail(client * c, websocketpp::connection_hdl hdl) {</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        m_status = &quot;Failed&quot;;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        client::connection_ptr con = c-&gt;get_con_from_hdl(hdl);</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        m_server = con-&gt;get_response_header(&quot;Server&quot;);</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        m_error_reason = con-&gt;get_ec().message();</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    }</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    friend std::ostream &amp; operator&lt;&lt; (std::ostream &amp; out, connection_metadata const &amp; data);</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;private:</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    int m_id;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    websocketpp::connection_hdl m_hdl;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    std::string m_status;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    std::string m_uri;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    std::string m_server;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    std::string m_error_reason;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;};</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;std::ostream &amp; operator&lt;&lt; (std::ostream &amp; out, connection_metadata const &amp; data) {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    out &lt;&lt; &quot;&gt; URI: &quot; &lt;&lt; data.m_uri &lt;&lt; &quot;\n&quot;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        &lt;&lt; &quot;&gt; Status: &quot; &lt;&lt; data.m_status &lt;&lt; &quot;\n&quot;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        &lt;&lt; &quot;&gt; Remote Server: &quot; &lt;&lt; (data.m_server.empty() ? &quot;None Specified&quot; : data.m_server) &lt;&lt; &quot;\n&quot;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        &lt;&lt; &quot;&gt; Error/close reason: &quot; &lt;&lt; (data.m_error_reason.empty() ? &quot;N/A&quot; : data.m_error_reason);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    return out;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;}</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;class websocket_endpoint {</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;public:</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    websocket_endpoint () : m_next_id(0) {</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        m_endpoint.init_asio();</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        m_endpoint.start_perpetual();</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        m_thread.reset(new websocketpp::lib::thread(&amp;client::run, &amp;m_endpoint));</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    }</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    int connect(std::string const &amp; uri) {</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        websocketpp::lib::error_code ec;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        client::connection_ptr con = m_endpoint.get_connection(uri, ec);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        if (ec) {</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            std::cout &lt;&lt; &quot;&gt; Connect initialization error: &quot; &lt;&lt; ec.message() &lt;&lt; std::endl;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            return -1;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        }</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        int new_id = m_next_id++;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        connection_metadata::ptr metadata_ptr(new connection_metadata(new_id, con-&gt;get_handle(), uri));</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        m_connection_list[new_id] = metadata_ptr;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        con-&gt;set_open_handler(websocketpp::lib::bind(</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;            &amp;connection_metadata::on_open,</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            metadata_ptr,</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            &amp;m_endpoint,</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            websocketpp::lib::placeholders::_1</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        ));</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        con-&gt;set_fail_handler(websocketpp::lib::bind(</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            &amp;connection_metadata::on_fail,</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;            metadata_ptr,</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            &amp;m_endpoint,</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;            websocketpp::lib::placeholders::_1</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        ));</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        m_endpoint.connect(con);</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        return new_id;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    }</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    connection_metadata::ptr get_metadata(int id) const {</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        con_list::const_iterator metadata_it = m_connection_list.find(id);</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        if (metadata_it == m_connection_list.end()) {</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;            return connection_metadata::ptr();</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        } else {</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;            return metadata_it-&gt;second;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        }</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    }</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;private:</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    typedef std::map&lt;int,connection_metadata::ptr&gt; con_list;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    client m_endpoint;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    websocketpp::lib::shared_ptr&lt;websocketpp::lib::thread&gt; m_thread;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    con_list m_connection_list;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    int m_next_id;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;};</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;int main() {</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    bool done = false;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    std::string input;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    websocket_endpoint endpoint;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    while (!done) {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        std::cout &lt;&lt; &quot;Enter Command: &quot;;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        std::getline(std::cin, input);</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        if (input == &quot;quit&quot;) {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            done = true;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        } else if (input == &quot;help&quot;) {</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            std::cout</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                &lt;&lt; &quot;\nCommand List:\n&quot;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                &lt;&lt; &quot;connect &lt;ws uri&gt;\n&quot;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                &lt;&lt; &quot;show &lt;connection id&gt;\n&quot;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                &lt;&lt; &quot;help: Display this help text\n&quot;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                &lt;&lt; &quot;quit: Exit the program\n&quot;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                &lt;&lt; std::endl;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        } else if (input.substr(0,7) == &quot;connect&quot;) {</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            int id = endpoint.connect(input.substr(8));</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            if (id != -1) {</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                std::cout &lt;&lt; &quot;&gt; Created connection with id &quot; &lt;&lt; id &lt;&lt; std::endl;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            }</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        } else if (input.substr(0,4) == &quot;show&quot;) {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;            int id = atoi(input.substr(5).c_str());</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;            connection_metadata::ptr metadata = endpoint.get_metadata(id);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            if (metadata) {</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                std::cout &lt;&lt; *metadata &lt;&lt; std::endl;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            } else {</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                std::cout &lt;&lt; &quot;&gt; Unknown connection id &quot; &lt;&lt; id &lt;&lt; std::endl;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            }</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        } else {</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            std::cout &lt;&lt; &quot;&gt; Unrecognized Command&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        }</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    }</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    return 0;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;}</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;```</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;### Step 5</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;_Closing connections_</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;This step adds a command that allows you to close a WebSocket connection and adjusts the quit command so that it cleanly closes all outstanding connections before quitting.</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;#### Getting connection close information out of WebSocket++</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;&gt; ###### Terminology: WebSocket close codes &amp; reasons</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;&gt; The WebSocket close handshake involves an exchange of optional machine readable close codes and human readable reason strings. Each endpoint sends independent close details. The codes are short integers. The reasons are UTF8 text strings of at most 125 characters. More details about valid close code ranges and the meaning of each code can be found at https://tools.ietf.org/html/rfc6455#section-7.4</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;The `websocketpp::close::status` namespace contains named constants for all of the IANA defined close codes. It also includes free functions to determine whether a value is reserved or invalid and to convert a code to a human readable text representation.</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;During the close handler call WebSocket++ connections offer the following methods for accessing close handshake information:</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;- `connection::get_remote_close_code()`: Get the close code as reported by the remote endpoint</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;- `connection::get_remote_close_reason()`: Get the close reason as reported by the remote endpoint</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;- `connection::get_local_close_code()`: Get the close code that this endpoint sent.</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;- `connection::get_local_close_reason()`: Get the close reason that this endpoint sent.</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;- `connection::get_ec()`: Get a more detailed/specific WebSocket++ `error_code` indicating what library error (if any) ultimately resulted in the connection closure.</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;*Note:* there are some special close codes that will report a code that was not actually sent on the wire. For example 1005/&quot;no close code&quot; indicates that the endpoint omitted a close code entirely and 1006/&quot;abnormal close&quot; indicates that there was a problem that resulted in the connection closing without having performed a close handshake.</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;#### Add close handler</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;The `connection_metadata::on_close` method is added. This method retrieves the close code and reason from the closing handshake and stores it in the local error reason field.</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;```cpp</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;void on_close(client * c, websocketpp::connection_hdl hdl) {</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    m_status = &quot;Closed&quot;;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    client::connection_ptr con = c-&gt;get_con_from_hdl(hdl);</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    std::stringstream s;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    s &lt;&lt; &quot;close code: &quot; &lt;&lt; con-&gt;get_remote_close_code() &lt;&lt; &quot; (&quot; </div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;      &lt;&lt; websocketpp::close::status::get_string(con-&gt;get_remote_close_code()) </div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;      &lt;&lt; &quot;), close reason: &quot; &lt;&lt; con-&gt;get_remote_close_reason();</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    m_error_reason = s.str();</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;}</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;```</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;Similarly to `on_open` and `on_fail`, `websocket_endpoint::connect` registers this close handler when a new connection is made.</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;#### Add close method to `websocket_endpoint`</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;This method starts by looking up the given connection ID in the connection list.  Next a close request is sent to the connection&#39;s handle with the specified WebSocket close code. This is done by calling `endpoint::close`. This is a thread safe method that is used to asynchronously dispatch a close signal to the connection with the given handle. When the operation is complete the connection&#39;s close handler will be triggered.</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;```cpp</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;void close(int id, websocketpp::close::status::value code) {</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    websocketpp::lib::error_code ec;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    </div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    con_list::iterator metadata_it = m_connection_list.find(id);</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    if (metadata_it == m_connection_list.end()) {</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        std::cout &lt;&lt; &quot;&gt; No connection found with id &quot; &lt;&lt; id &lt;&lt; std::endl;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        return;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    }</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    </div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    m_endpoint.close(metadata_it-&gt;second-&gt;get_hdl(), code, &quot;&quot;, ec);</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    if (ec) {</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        std::cout &lt;&lt; &quot;&gt; Error initiating close: &quot; &lt;&lt; ec.message() &lt;&lt; std::endl;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    }</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;}</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;```</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;#### Add close option to the command loop and help message</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;A close option is added to the command loop. It takes a connection ID and optionally a close code and a close reason. If no code is specified the default of 1000/Normal is used. If no reason is specified, none is sent. The `endpoint::close` method will do some error checking and abort the close request if you try and send an invalid code or a reason with invalid UTF8 formatting. Reason strings longer than 125 characters will be truncated.</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;An entry is also added to the help system to describe how the new command may be used.</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;```cpp</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;else if (input.substr(0,5) == &quot;close&quot;) {</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    std::stringstream ss(input);</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    </div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    std::string cmd;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    int id;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    int close_code = websocketpp::close::status::normal;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    std::string reason = &quot;&quot;;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    </div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;    ss &gt;&gt; cmd &gt;&gt; id &gt;&gt; close_code;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    std::getline(ss,reason);</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    </div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    endpoint.close(id, close_code, reason);</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;}</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;```</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;#### Close all outstanding connections in `websocket_endpoint` destructor</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;Until now quitting the program left outstanding connections and the WebSocket++ network thread in a lurch. Now that we have a method of closing connections we can clean this up properly.</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;The destructor for `websocket_endpoint` now stops perpetual mode (so the run thread exits after the last connection is closed) and iterates through the list of open connections and requests a clean close for each. Finally, the run thread is joined which causes the program to wait until those connection closes complete.</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;```cpp</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;~websocket_endpoint() {</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    m_endpoint.stop_perpetual();</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    </div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    for (con_list::const_iterator it = m_connection_list.begin(); it != m_connection_list.end(); ++it) {</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;        if (it-&gt;second-&gt;get_status() != &quot;Open&quot;) {</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;            // Only close open connections</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;            continue;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        }</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        </div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        std::cout &lt;&lt; &quot;&gt; Closing connection &quot; &lt;&lt; it-&gt;second-&gt;get_id() &lt;&lt; std::endl;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        </div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        websocketpp::lib::error_code ec;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        m_endpoint.close(it-&gt;second-&gt;get_hdl(), websocketpp::close::status::going_away, &quot;&quot;, ec);</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        if (ec) {</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            std::cout &lt;&lt; &quot;&gt; Error closing connection &quot; &lt;&lt; it-&gt;second-&gt;get_id() &lt;&lt; &quot;: &quot;  </div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;                      &lt;&lt; ec.message() &lt;&lt; std::endl;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        }</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    }</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    </div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    m_thread-&gt;join();</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;}</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;```</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;#### Build</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;There are no changes to the build instructions from step 4</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;#### Run</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;```</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;Enter Command: connect ws://localhost:9002</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;&gt; Created connection with id 0</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;Enter Command: close 0 1001 example message</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;Enter Command: show 0</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;&gt; URI: ws://localhost:9002</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;&gt; Status: Closed</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;&gt; Remote Server: WebSocket++/0.4.0</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;&gt; Error/close reason: close code: 1001 (Going away), close reason:  example message</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;Enter Command: connect ws://localhost:9002</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;&gt; Created connection with id 1</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;Enter Command: close 1 1006</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;&gt; Error initiating close: Invalid close code used</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;Enter Command: quit</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;&gt; Closing connection 1</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;```</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;### Step 6</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;_Sending and receiving messages_</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;This step adds a command to send a message on a given connection and updates the show command to print a transcript of all sent and received messages for that connection.</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;&gt; ###### Terminology: WebSocket message types (opcodes)</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;&gt; WebSocket messages have types indicated by their opcode. The protocol currently specifies two different opcodes for data messages, text and binary. Text messages represent UTF8 text and will be validated as such. Binary messages represent raw binary bytes and are passed through directly with no validation. </div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;&gt;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;&gt; WebSocket++ provides the values `websocketpp::frame::opcode::text` and `websocketpp::frame::opcode::binary` that can be used to direct how outgoing messages should be sent and to check how incoming messages are formatted.</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;#### Sending Messages</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;Messages are sent using `endpoint::send`. This is a thread safe method that may be called from anywhere to queue a message for sending on the specified connection. There are three send overloads for use with different scenarios. </div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;Each method takes a `connection_hdl` to indicate which connection to send the message on as well as a `frame::opcode::value` to indicate which opcode to label the message as. All overloads are also available with an exception free varient that fills in a a status/error code instead of throwing.</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;The first overload, `connection_hdl hdl, std::string const &amp; payload, frame::opcode::value op`, takes a `std::string`. The string contents are copied into an internal buffer and can be safely modified after calling send.</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;The second overload, `connection_hdl hdl, void const * payload, size_t len, frame::opcode::value op`, takes a void * buffer and length. The buffer contents are copied and can be safely modified after calling send.</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;The third overload, `connection_hdl hdl, message_ptr msg`, takes a WebSocket++ `message_ptr`. This overload allows a message to be constructed in place before the call to send. It also may allow a single message buffer to be sent multiple times, including to multiple connections, without copying. Whether or not this actually happens depends on other factors such as whether compression is enabled. The contents of the message buffer may not be safely modified after being sent.</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;&gt; ###### Terminology: Outgoing WebSocket message queueing &amp; flow control</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;&gt; In many configurations, such as when the Asio based transport is in use, WebSocket++ is an asynchronous system. As such the `endpoint::send` method may return before any bytes are actually written to the outgoing socket. In cases where send is called multiple times in quick succession messages may be coalesced and sent in the same operation or even the same TCP packet. When this happens the message boundaries are preserved (each call to send will produce a separate message).</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;&gt;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;&gt; In the case of applications that call send from inside a handler this means that no messages will be written to the socket until that handler returns. If you are planning to send many messages in this manor or need a message to be written on the wire before continuing you should look into using multiple threads or the built in timer/interrupt handler functionality.</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;&gt;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;&gt; If the outgoing socket link is slow messages may build up in this queue. You can use `connection::get_buffered_amount` to query the current size of the written message queue to decide if you want to change your sending behavior.</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;#### Add send method to `websocket_endpoint`</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;Like the close method, send will start by looking up the given connection ID in the connection list.  Next a send request is sent to the connection&#39;s handle with the specified WebSocket message and the text opcode. Finally, we record the sent message with our connection metadata object so later our show connection command can print a list of messages sent.</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;```cpp</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;void send(int id, std::string message) {</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;    websocketpp::lib::error_code ec;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    </div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;    con_list::iterator metadata_it = m_connection_list.find(id);</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    if (metadata_it == m_connection_list.end()) {</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;        std::cout &lt;&lt; &quot;&gt; No connection found with id &quot; &lt;&lt; id &lt;&lt; std::endl;</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        return;</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    }</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    </div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    m_endpoint.send(metadata_it-&gt;second-&gt;get_hdl(), message, websocketpp::frame::opcode::text, ec);</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    if (ec) {</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        std::cout &lt;&lt; &quot;&gt; Error sending message: &quot; &lt;&lt; ec.message() &lt;&lt; std::endl;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;        return;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    }</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    </div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    metadata_it-&gt;second-&gt;record_sent_message(message);</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;}</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;```</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;#### Add send option to the command loop and help message</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;A send option is added to the command loop. It takes a connection ID and a text message to send. An entry is also added to the help system to describe how the new command may be used.</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;```cpp</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;else if (input.substr(0,4) == &quot;send&quot;) {</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;    std::stringstream ss(input);</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        </div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        std::string cmd;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        int id;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        std::string message = &quot;&quot;;</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        </div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        ss &gt;&gt; cmd &gt;&gt; id;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        std::getline(ss,message);</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        </div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;        endpoint.send(id, message);</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;}</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;```</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;#### Add glue to `connection_metadata` for storing sent messages</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;In order to store messages sent on this connection some code is added to `connection_metadata`. This includes a new data member `std::vector&lt;std::string&gt; m_messages` to keep track of all messages sent and received as well as a method for adding a sent message in that list:</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;```cpp</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;void record_sent_message(std::string message) {</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;    m_messages.push_back(&quot;&gt;&gt; &quot; + message);</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;}</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;```</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;Finally the connection metadata output operator is updated to also print a list of processed messages:</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;```cpp</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;out &lt;&lt; &quot;&gt; Messages Processed: (&quot; &lt;&lt; data.m_messages.size() &lt;&lt; &quot;) \n&quot;;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;std::vector&lt;std::string&gt;::const_iterator it;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;for (it = data.m_messages.begin(); it != data.m_messages.end(); ++it) {</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    out &lt;&lt; *it &lt;&lt; &quot;\n&quot;;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;}</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;```</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;#### Receiving Messages</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;Messages are received by registering a message handler. This handler will be called once per message received and its signature is `void on_message(websocketpp::connection_hdl hdl, endpoint::message_ptr msg)`. The `connection_hdl`, like the similar parameter from the other handlers is a handle for the connection that the message was received on. The `message_ptr` is a pointer to an object that can be queried for the message payload, opcode, and other metadata. Note that the message_ptr type, as well as its underlying message type, is dependent on how your endpoint is configured and may be different for different configs.</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;#### Add a message handler to method to `connection_metadata`</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;The message receiving behave that we are implementing will be to collect all messages sent and received and to print them in order when the show connection command is run. The sent messages are already being added to that list. Now we add a message handler that pushes received messages to the list as well. Text messages are pushed as-is. Binary messages are first converted to printable hexadecimal format.</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;```cpp</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;void on_message(websocketpp::connection_hdl hdl, client::message_ptr msg) {</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    if (msg-&gt;get_opcode() == websocketpp::frame::opcode::text) {</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;        m_messages.push_back(msg-&gt;get_payload());</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    } else {</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;        m_messages.push_back(websocketpp::utility::to_hex(msg-&gt;get_payload()));</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;    }</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;}</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;```</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;In order to have this handler called when new messages are received we also register it with our connection. Note that unlike most other handlers, the message handler has two parameters and thus needs two placeholders.</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;```cpp</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;con-&gt;set_message_handler(websocketpp::lib::bind(</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;    &amp;connection_metadata::on_message,</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    metadata_ptr,</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    websocketpp::lib::placeholders::_1,</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    websocketpp::lib::placeholders::_2</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;));</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;```</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;#### Build</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;There are no changes to the build instructions from step 5</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;#### Run</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;In this example run we are connecting to the WebSocket++ example echo_server. This server will repeat any message we send back to it. You can also try testing this with the echo server at `ws://echo.websocket.org` with similar results.</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;```</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;Enter Command: connect ws://localhost:9002</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;&gt; Created connection with id 0</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;Enter Command: send 0 example message</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;Enter Command: show 0</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;&gt; URI: ws://localhost:9002</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;&gt; Status: Open</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;&gt; Remote Server: WebSocket++/0.4.0</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;&gt; Error/close reason: N/A</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;&gt; Messages Processed: (2)</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;&gt;&gt;  example message</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;&lt;&lt;  example message</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;```</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;### Step 7</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;_Using TLS / Secure WebSockets_</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;Chapter 2: Intermediate Features</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;--------------------------------</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;### Step 8</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;_Intermediate level features_</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;- Subprotocol negotiation</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;- Setting and reading custom headers</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;- Ping and Pong</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;- Proxies?</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;- Setting user agent</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;- Setting Origin</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;- Timers and security</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;- Close behavior</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;- Send one message to all connections</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;### Misc stuff not sure if it should be included here or elsewhere?</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;core websocket++ control flow.</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;A handshake, followed by a split into 2 independent control strands</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;- Handshake</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;-- use information specified before the call to endpoint::connect to construct a WebSocket handshake request.</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;-- Pass the WebSocket handshake request to the transport policy. The transport policy determines how to get these bytes to the endpoint playing the server role. Depending on which transport policy your endpoint uses this method will be different.</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;-- Receive a handshake response from the underlying transport. This is parsed and checked for conformance to RFC6455. If the validation fails, the fail handler is called. Otherwise the open handler is called.</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;- At this point control splits into two separate strands. One that reads new bytes from the transport policy on the incoming channle, the other that accepts new messages from the local application for framing and writing to the outgoing transport channel.</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;- Read strand</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;-- Read and process new bytes from transport</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;-- If the bytes contain at least one complete message dispatch each message by calling the appropriate handler. This is either the message handler for data messages, or ping/pong/close handlers for each respective control message. If no handler is registered for a particular message it is ignored.</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;-- Ask the transport layer for more bytes</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;- Write strand</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;-- Wait for messages from the application</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;-- Perform error checking on message input,</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;-- Frame message per RFC6455</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;-- Queue message for sending</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;-- Pass all outstanding messages to the transport policy for output</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;-- When there are no messages left to send, return to waiting</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;Important observations</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;Handlers run in line with library processing which has several implications applications should be aware of:</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
